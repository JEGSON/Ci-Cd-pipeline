"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPriorities = exports.Tag = exports.ShaFormat = exports.RefEvent = exports.Type = void 0;
exports.Transform = Transform;
exports.Parse = Parse;
const sync_1 = require("csv-parse/sync");
var Type;
(function (Type) {
    Type["Schedule"] = "schedule";
    Type["Semver"] = "semver";
    Type["Pep440"] = "pep440";
    Type["Match"] = "match";
    Type["Edge"] = "edge";
    Type["Ref"] = "ref";
    Type["Raw"] = "raw";
    Type["Sha"] = "sha";
})(Type || (exports.Type = Type = {}));
var RefEvent;
(function (RefEvent) {
    RefEvent["Branch"] = "branch";
    RefEvent["Tag"] = "tag";
    RefEvent["PR"] = "pr";
})(RefEvent || (exports.RefEvent = RefEvent = {}));
var ShaFormat;
(function (ShaFormat) {
    ShaFormat["Short"] = "short";
    ShaFormat["Long"] = "long";
})(ShaFormat || (exports.ShaFormat = ShaFormat = {}));
class Tag {
    type;
    attrs;
    constructor() {
        this.attrs = {};
    }
    toString() {
        const out = [`type=${this.type}`];
        for (const attr in this.attrs) {
            out.push(`${attr}=${this.attrs[attr]}`);
        }
        return out.join(',');
    }
}
exports.Tag = Tag;
exports.DefaultPriorities = {
    [Type.Schedule]: '1000',
    [Type.Semver]: '900',
    [Type.Pep440]: '900',
    [Type.Match]: '800',
    [Type.Edge]: '700',
    [Type.Ref]: '600',
    [Type.Raw]: '200',
    [Type.Sha]: '100',
};
function Transform(inputs, logger) {
    const tags = [];
    if (inputs.length == 0) {
        // prettier-ignore
        inputs = [
            `type=schedule`,
            `type=ref,event=${RefEvent.Branch}`,
            `type=ref,event=${RefEvent.Tag}`,
            `type=ref,event=${RefEvent.PR}`
        ];
    }
    for (const input of inputs) {
        tags.push(Parse(input));
    }
    const sorted = tags.sort((tag1, tag2) => {
        if (Number(tag1.attrs['priority']) < Number(tag2.attrs['priority'])) {
            return 1;
        }
        if (Number(tag1.attrs['priority']) > Number(tag2.attrs['priority'])) {
            return -1;
        }
        return 0;
    });
    const group = 'Processing tags input';
    logger.startGroup(group);
    for (const tag of sorted) {
        logger.info(tag.toString());
    }
    logger.endGroup(group);
    return sorted;
}
function Parse(s) {
    const fields = (0, sync_1.parse)(s, {
        relaxColumnCount: true,
        skipEmptyLines: true,
    })[0];
    const tag = new Tag();
    for (const field of fields) {
        const parts = field
            .toString()
            .split(/(?<=^[^=]+?)=/)
            .map((item) => item.trim());
        if (parts.length == 1) {
            tag.attrs['value'] = parts[0];
        }
        else {
            const key = parts[0].toLowerCase();
            const value = parts[1];
            switch (key) {
                case 'type': {
                    if (!Object.values(Type).includes(value)) {
                        throw new Error(`Unknown tag type attribute: ${value}`);
                    }
                    tag.type = value;
                    break;
                }
                default: {
                    tag.attrs[key] = value;
                    break;
                }
            }
        }
    }
    if (tag.type == undefined) {
        tag.type = Type.Raw;
    }
    switch (tag.type) {
        case Type.Schedule: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'pattern')) {
                tag.attrs['pattern'] = 'nightly';
            }
            break;
        }
        case Type.Semver:
        case Type.Pep440: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'pattern')) {
                throw new Error(`Missing pattern attribute for ${s}`);
            }
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'value')) {
                tag.attrs['value'] = '';
            }
            break;
        }
        case Type.Match: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'pattern')) {
                throw new Error(`Missing pattern attribute for ${s}`);
            }
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'group')) {
                tag.attrs['group'] = '0';
            }
            if (isNaN(+tag.attrs['group'])) {
                throw new Error(`Invalid match group for ${s}`);
            }
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'value')) {
                tag.attrs['value'] = '';
            }
            break;
        }
        case Type.Edge: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'branch')) {
                tag.attrs['branch'] = '';
            }
            break;
        }
        case Type.Ref: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'event')) {
                throw new Error(`Missing event attribute for ${s}`);
            }
            if (!Object.keys(RefEvent)
                .map((k) => RefEvent[k])
                .includes(tag.attrs['event'])) {
                throw new Error(`Invalid event for ${s}`);
            }
            if (tag.attrs['event'] == RefEvent.PR && !Object.prototype.hasOwnProperty.call(tag.attrs, 'prefix')) {
                tag.attrs['prefix'] = 'pr-';
            }
            break;
        }
        case Type.Raw: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'value')) {
                throw new Error(`Missing value attribute for ${s}`);
            }
            break;
        }
        case Type.Sha: {
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'prefix')) {
                tag.attrs['prefix'] = 'sha-';
            }
            if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'format')) {
                tag.attrs['format'] = ShaFormat.Short;
            }
            if (!Object.keys(ShaFormat)
                .map((k) => ShaFormat[k])
                .includes(tag.attrs['format'])) {
                throw new Error(`Invalid format for ${s}`);
            }
            break;
        }
    }
    if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'enable')) {
        tag.attrs['enable'] = 'true';
    }
    if (!Object.prototype.hasOwnProperty.call(tag.attrs, 'priority')) {
        tag.attrs['priority'] = exports.DefaultPriorities[tag.type];
    }
    return tag;
}
