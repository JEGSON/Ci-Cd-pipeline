"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInputs = getInputs;
exports.getContext = getContext;
const tslib_1 = require("tslib");
const ci_context_1 = require("@nx-tools/ci-context");
const core = tslib_1.__importStar(require("@nx-tools/core"));
const devkit_1 = require("@nx/devkit");
function getInputs(options, ctx) {
    const prefix = (0, devkit_1.names)(ctx?.projectName || '').constantName;
    return {
        quiet: options.quiet || false,
        'bake-target': core.getInput('bake-target', {
            prefix,
            fallback: options['bake-target'] || 'container-metadata-action',
        }),
        'github-token': core.getInput('github-token'),
        'sep-annotations': core.getInput('sep-annotations', {
            prefix,
            fallback: options['sep-annotations'] || '\n',
            trimWhitespace: false,
        }),
        'sep-labels': core.getInput('sep-labels', {
            prefix,
            fallback: options['sep-labels'] || '\n',
            trimWhitespace: false,
        }),
        'sep-tags': core.getInput('sep-tags', { prefix, fallback: options['sep-tags'] || '\n', trimWhitespace: false }),
        annotations: core
            .getInputList('annotations', {
            prefix,
            fallback: options.annotations,
            ignoreComma: true,
            comment: '#',
        })
            .map((flavor) => core.interpolate(flavor)),
        flavor: core
            .getInputList('flavor', { prefix, fallback: options.flavor, ignoreComma: true, comment: '#' })
            .map((flavor) => core.interpolate(flavor)),
        images: core
            .getInputList('images', { prefix, fallback: options.images, ignoreComma: true, comment: '#' })
            .map((image) => core.interpolate(image)),
        labels: core
            .getInputList('labels', { prefix, fallback: options.labels, ignoreComma: true, comment: '#' })
            .map((label) => core.interpolate(label)),
        tags: core
            .getInputList('tags', { prefix, fallback: options.tags, ignoreComma: true, comment: '#' })
            .map((tag) => core.interpolate(tag)),
    };
}
async function getContext() {
    const context = await ci_context_1.ContextProxyFactory.create();
    if (context.name === 'GITHUB') {
        // Needs to override Git reference with pr ref instead of upstream branch ref
        // for pull_request_target event
        // https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target
        if (/pull_request_target/.test(context.eventName)) {
            context.ref = `refs/pull/${context.payload.number}/merge`;
        }
        // DOCKER_METADATA_PR_HEAD_SHA env var can be used to set associated head
        // SHA instead of commit SHA that triggered the workflow on pull request
        // event.
        if (/true/i.test(process.env.DOCKER_METADATA_PR_HEAD_SHA || '')) {
            if ((/pull_request/.test(context.eventName) || /pull_request_target/.test(context.eventName)) &&
                context.payload?.pull_request?.head?.sha != undefined) {
                context.sha = context.payload.pull_request.head.sha;
            }
        }
    }
    return context;
}
