"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Docker = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@nx-tools/core");
const devkit_1 = require("@nx/devkit");
const handlebars = tslib_1.__importStar(require("handlebars"));
const node_crypto_1 = require("node:crypto");
const engine_adapter_1 = require("../engine-adapter");
const buildx = tslib_1.__importStar(require("./buildx"));
const docker = tslib_1.__importStar(require("./docker"));
class Docker extends engine_adapter_1.EngineAdapter {
    standalone = true;
    createdBuilder = false;
    buildxVersion = '';
    getBuildxVersion() {
        return this.buildxVersion;
    }
    getCommand(args) {
        return buildx.getCommand(args, this.standalone);
    }
    async initialize(inputs, ctx) {
        // standalone if docker cli not available
        this.standalone = !(await docker.isAvailable());
        if (!inputs.quiet) {
            await core_1.logger.group(`Docker info`, async () => {
                if (this.standalone) {
                    core_1.logger.info('Docker info skipped in standalone mode');
                }
                else {
                    await (0, core_1.exec)('docker', ['version'], {
                        failOnStdErr: false,
                    });
                    await (0, core_1.exec)('docker', ['info'], {
                        failOnStdErr: false,
                    });
                }
            });
        }
        if (!(await buildx.isAvailable(this.standalone))) {
            throw new Error(`Docker buildx is required. See https://github.com/gperdomor/nx-tools to set up nx-container executor with buildx.`);
        }
        this.buildxVersion = await buildx.getVersion();
        if (!inputs.quiet) {
            await core_1.logger.group(`Buildx version`, async () => {
                const versionCmd = buildx.getCommand(['version'], this.standalone);
                await (0, core_1.exec)(versionCmd.command, versionCmd.args, {
                    failOnStdErr: false,
                });
            });
        }
        this.createdBuilder = (0, core_1.getBooleanInput)('create-builder', {
            prefix: (0, devkit_1.names)(ctx?.projectName || '').constantName,
            fallback: 'false',
        });
        if (this.createdBuilder) {
            inputs.builder = inputs.builder || `${ctx?.projectName}-${(0, node_crypto_1.randomBytes)(24).toString('hex').substring(0, 6)}`;
            core_1.logger.info(`Creating builder ${inputs.builder}`);
            const command = buildx.getCommand(['create', `--name=${inputs.builder}`], this.standalone);
            await (0, core_1.getExecOutput)(command.command, command.args, {
                ignoreReturnCode: true,
            }).then((res) => {
                if (res.stderr.length > 0 && res.exitCode != 0) {
                    throw new Error(`buildx failed with: ${res.stderr.match(/(.*)\s*$/)[0].trim()}`);
                }
            });
        }
    }
    async finalize(inputs, _ctx) {
        // startGroup(`Running post build steps`, GROUP_PREFIX);
        if (this.createdBuilder) {
            core_1.logger.info(`Removing builder ${this.createdBuilder}`);
            const command = buildx.getCommand(['rm', inputs.builder], this.standalone);
            await (0, core_1.getExecOutput)(command.command, command.args, {
                ignoreReturnCode: true,
            });
        }
    }
    async getImageID() {
        return buildx.getImageID();
    }
    async getMetadata() {
        return buildx.getMetadata();
    }
    async getDigest(metadata) {
        return buildx.getDigest(metadata);
    }
    async getArgs(inputs, defaultContext) {
        const context = handlebars.compile(inputs.context)({ defaultContext });
        // prettier-ignore
        return [
            ...await this.getBuildArgs(inputs, defaultContext, context, this.getBuildxVersion()),
            ...await this.getCommonArgs(inputs, this.getBuildxVersion()),
            context
        ];
    }
    async getBuildArgs(inputs, defaultContext, context, buildxVersion) {
        const args = ['build'];
        await (0, core_1.asyncForEach)(inputs.addHosts, async (addHost) => {
            args.push('--add-host', addHost);
        });
        if (inputs.allow.length > 0) {
            args.push('--allow', inputs.allow.join(','));
        }
        await (0, core_1.asyncForEach)(inputs.buildArgs, async (buildArg) => {
            args.push('--build-arg', buildArg);
        });
        if (buildx.satisfies(buildxVersion, '>=0.8.0')) {
            await (0, core_1.asyncForEach)(inputs.buildContexts, async (buildContext) => {
                args.push('--build-context', buildContext);
            });
        }
        await (0, core_1.asyncForEach)(inputs.cacheFrom, async (cacheFrom) => {
            args.push('--cache-from', cacheFrom);
        });
        await (0, core_1.asyncForEach)(inputs.cacheTo, async (cacheTo) => {
            args.push('--cache-to', cacheTo);
        });
        if (inputs.cgroupParent) {
            args.push('--cgroup-parent', inputs.cgroupParent);
        }
        if (inputs.file) {
            args.push('--file', inputs.file);
        }
        if (!buildx.isLocalOrTarExporter(inputs.outputs) &&
            (inputs.platforms.length == 0 || buildx.satisfies(buildxVersion, '>=0.4.2'))) {
            args.push('--iidfile', await buildx.getImageIDFile());
        }
        await (0, core_1.asyncForEach)(inputs.labels, async (label) => {
            args.push('--label', label);
        });
        await (0, core_1.asyncForEach)(inputs.noCacheFilters, async (noCacheFilter) => {
            args.push('--no-cache-filter', noCacheFilter);
        });
        await (0, core_1.asyncForEach)(inputs.outputs, async (output) => {
            args.push('--output', output);
        });
        if (inputs.platforms.length > 0) {
            args.push('--platform', inputs.platforms.join(','));
        }
        if (inputs.provenance || inputs.provenance === 'false') {
            args.push('--provenance', inputs.provenance);
        }
        await (0, core_1.asyncForEach)(inputs.secrets, async (secret) => {
            try {
                args.push('--secret', await buildx.getSecretString(secret));
            }
            catch (err) {
                core_1.logger.warn(this.getErrorMessage(err));
            }
        });
        await (0, core_1.asyncForEach)(inputs.secretFiles, async (secretFile) => {
            try {
                args.push('--secret', await buildx.getSecretFile(secretFile));
            }
            catch (err) {
                core_1.logger.warn(this.getErrorMessage(err));
            }
        });
        if (inputs.githubToken && !buildx.hasGitAuthToken(inputs.secrets) && context.startsWith(defaultContext)) {
            args.push('--secret', await buildx.getSecretString(`GIT_AUTH_TOKEN=${inputs.githubToken}`));
        }
        if (inputs.sbom) {
            args.push('--attest', 'type=sbom');
        }
        if (inputs.shmSize) {
            args.push('--shm-size', inputs.shmSize);
        }
        await (0, core_1.asyncForEach)(inputs.ssh, async (ssh) => {
            args.push('--ssh', ssh);
        });
        await (0, core_1.asyncForEach)(inputs.tags, async (tag) => {
            args.push('--tag', tag);
        });
        if (inputs.target) {
            args.push('--target', inputs.target);
        }
        await (0, core_1.asyncForEach)(inputs.ulimit, async (ulimit) => {
            args.push('--ulimit', ulimit);
        });
        return args;
    }
    async getCommonArgs(inputs, buildxVersion) {
        const args = [];
        if (inputs.builder) {
            args.push('--builder', inputs.builder);
        }
        if (inputs.load) {
            args.push('--load');
        }
        if (buildx.satisfies(buildxVersion, '>=0.6.0')) {
            args.push('--metadata-file', await buildx.getMetadataFile());
        }
        if (inputs.network) {
            args.push('--network', inputs.network);
        }
        if (inputs.noCache) {
            args.push('--no-cache');
        }
        if (inputs.pull) {
            args.push('--pull');
        }
        if (inputs.push) {
            args.push('--push');
        }
        return args;
    }
}
exports.Docker = Docker;
