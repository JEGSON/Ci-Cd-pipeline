"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getImageIDFile = getImageIDFile;
exports.getImageID = getImageID;
exports.getMetadataFile = getMetadataFile;
exports.getMetadata = getMetadata;
exports.getDigest = getDigest;
exports.getSecretString = getSecretString;
exports.getSecretFile = getSecretFile;
exports.getSecret = getSecret;
exports.isLocalOrTarExporter = isLocalOrTarExporter;
exports.hasGitAuthToken = hasGitAuthToken;
exports.isAvailable = isAvailable;
exports.getVersion = getVersion;
exports.parseVersion = parseVersion;
exports.satisfies = satisfies;
exports.getCommand = getCommand;
const tslib_1 = require("tslib");
const core = tslib_1.__importStar(require("@nx-tools/core"));
const core_1 = require("@nx-tools/core");
const sync_1 = require("csv-parse/sync");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const semver = tslib_1.__importStar(require("semver"));
const context = tslib_1.__importStar(require("../../context"));
async function getImageIDFile() {
    return node_path_1.default.join(context.tmpDir(), 'iidfile').split(node_path_1.default.sep).join(node_path_1.default.posix.sep);
}
async function getImageID() {
    const iidFile = await getImageIDFile();
    if (!node_fs_1.default.existsSync(iidFile)) {
        return undefined;
    }
    return node_fs_1.default.readFileSync(iidFile, { encoding: 'utf-8' }).trim();
}
async function getMetadataFile() {
    return node_path_1.default.join(context.tmpDir(), 'metadata-file').split(node_path_1.default.sep).join(node_path_1.default.posix.sep);
}
async function getMetadata() {
    const metadataFile = await getMetadataFile();
    if (!node_fs_1.default.existsSync(metadataFile)) {
        return undefined;
    }
    const content = node_fs_1.default.readFileSync(metadataFile, { encoding: 'utf-8' }).trim();
    if (content === 'null') {
        return undefined;
    }
    return content;
}
async function getDigest(metadata) {
    if (metadata === undefined) {
        return undefined;
    }
    const metadataJSON = JSON.parse(metadata);
    if (metadataJSON['containerimage.digest']) {
        return metadataJSON['containerimage.digest'];
    }
    return undefined;
}
async function getSecretString(kvp) {
    return getSecret(kvp, false);
}
async function getSecretFile(kvp) {
    return getSecret(kvp, true);
}
async function getSecret(kvp, file) {
    const delimiterIndex = kvp.indexOf('=');
    const key = kvp.substring(0, delimiterIndex);
    let value = kvp.substring(delimiterIndex + 1);
    if (key.length == 0 || value.length == 0) {
        throw new Error(`${kvp} is not a valid secret`);
    }
    const interpolated = (0, core_1.interpolate)(value);
    if (file) {
        if (!node_fs_1.default.existsSync(interpolated)) {
            throw new Error(`secret file ${interpolated} not found`);
        }
        value = node_fs_1.default.readFileSync(interpolated, { encoding: 'utf-8' });
    }
    else {
        value = interpolated;
    }
    const secretFile = context.tmpNameSync({
        tmpdir: context.tmpDir(),
    });
    node_fs_1.default.writeFileSync(secretFile, value);
    return `id=${key},src=${secretFile}`;
}
function isLocalOrTarExporter(outputs) {
    const records = (0, sync_1.parse)(outputs.join(`\n`), {
        delimiter: ',',
        trim: true,
        columns: false,
        relaxColumnCount: true,
    });
    for (const record of records) {
        // Local if no type is defined
        // https://github.com/docker/buildx/blob/d2bf42f8b4784d83fde17acb3ed84703ddc2156b/build/output.go#L29-L43
        if (record.length == 1 && !record[0].startsWith('type=')) {
            return true;
        }
        for (const [key, value] of record.map((chunk) => chunk.split('=').map((item) => item.trim()))) {
            if (key == 'type' && (value == 'local' || value == 'tar')) {
                return true;
            }
        }
    }
    return false;
}
function hasGitAuthToken(secrets) {
    for (const secret of secrets) {
        if (secret.startsWith('GIT_AUTH_TOKEN=')) {
            return true;
        }
    }
    return false;
}
async function isAvailable() {
    const cmd = getCommand(['version']);
    return await core
        .getExecOutput(cmd.command, cmd.args, {
        ignoreReturnCode: true,
        silent: true,
    })
        .then((res) => {
        if (res.stderr.length > 0 && res.exitCode != 0) {
            return false;
        }
        return res.exitCode == 0;
    })
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        .catch((error) => {
        return false;
    });
}
async function getVersion() {
    const cmd = getCommand(['--version']);
    return await core
        .getExecOutput(cmd.command, cmd.args, {
        ignoreReturnCode: true,
        silent: true,
    })
        .then((res) => {
        if (res.stderr.length > 0 && res.exitCode != 0) {
            throw new Error(res.stderr.trim());
        }
        return parseVersion(res.stdout.trim());
    });
}
function parseVersion(stdout) {
    const matches = /\sv?([0-9a-f]{7}|[0-9.]+)/.exec(stdout);
    if (!matches) {
        throw new Error(`Cannot parse podman version`);
    }
    return matches[1];
}
function satisfies(version, range) {
    return semver.satisfies(version, range) || /^[0-9a-f]{7}$/.exec(version) !== null;
}
function getCommand(args) {
    return {
        command: 'podman',
        args,
    };
}
