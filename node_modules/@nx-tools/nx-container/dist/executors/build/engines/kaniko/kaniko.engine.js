"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kaniko = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@nx-tools/core");
const handlebars = tslib_1.__importStar(require("handlebars"));
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const engine_adapter_1 = require("../engine-adapter");
const kaniko = tslib_1.__importStar(require("./kaniko"));
class Kaniko extends engine_adapter_1.EngineAdapter {
    originalDirs = [];
    getCommand(args) {
        return {
            command: '/kaniko/executor',
            args,
        };
    }
    async initialize(inputs, _ctx) {
        if (!(await kaniko.isAvailable())) {
            throw new Error(`Kaniko is required. See https://github.com/gperdomor/nx-tools to set up nx-container executor with kaniko.`);
        }
        if (!inputs.quiet) {
            await core_1.logger.group(`Kaniko info`, async () => {
                const cmd = kaniko.getCommand(['version']);
                await (0, core_1.exec)(cmd.command, cmd.args, {
                    failOnStdErr: false,
                });
            });
        }
        this.originalDirs = await (0, promises_1.readdir)('/kaniko');
    }
    async finalize(_inputs, _ctx) {
        const dir = await (0, promises_1.readdir)('/kaniko');
        const toDelete = dir.filter((file) => !this.originalDirs.includes(file));
        await (0, core_1.asyncForEach)(toDelete, async (fileOrDir) => {
            await (0, promises_1.rm)((0, node_path_1.join)('/kaniko', fileOrDir), { force: true, recursive: true });
        });
    }
    async getImageID() {
        return kaniko.getImageID();
    }
    async getMetadata() {
        return kaniko.getMetadata();
    }
    async getDigest(metadata) {
        return kaniko.getDigest(metadata);
    }
    async getArgs(inputs, defaultContext) {
        const context = handlebars.compile(inputs.context)({ defaultContext });
        // prettier-ignore
        return [
            ...await this.getBuildArgs(inputs /*, defaultContex, context, this.getBuildxVersion()*/),
            ...await this.getCommonArgs(inputs /*, this.getBuildxVersion()*/),
            `--context=${context}`
        ];
    }
    async getBuildArgs(inputs
    /*defaultContext: string,
    context: string,
    buildxVersion: string*/
    ) {
        const args = [];
        await (0, core_1.asyncForEach)(inputs.buildArgs, async (buildArg) => {
            args.push('--build-arg', buildArg);
        });
        await (0, core_1.asyncForEach)(inputs.cacheFrom, async (cacheFrom) => {
            args.push('--cache-repo', cacheFrom);
        });
        if (inputs.file) {
            args.push('--dockerfile', inputs.file);
        }
        await (0, core_1.asyncForEach)(inputs.labels, async (label) => {
            args.push('--label', label);
        });
        if (inputs.platforms.length > 0) {
            args.push('--customPlatform', inputs.platforms.join(','));
        }
        await (0, core_1.asyncForEach)(inputs.tags, async (tag) => {
            args.push('--destination', tag);
        });
        if (inputs.target) {
            args.push('--target', inputs.target);
        }
        return args;
    }
    async getCommonArgs(inputs /*, buildxVersion: string*/) {
        const args = [];
        if (!inputs.noCache) {
            args.push('--cache=true');
        }
        if (!inputs.push) {
            args.push('--no-push');
        }
        args.push('--use-new-run');
        return args;
    }
}
exports.Kaniko = Kaniko;
