"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@nx-tools/core");
const devkit_1 = require("@nx/devkit");
require("dotenv/config");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const context = tslib_1.__importStar(require("./context"));
const engine_factory_1 = require("./engines/engine.factory");
const runExecutor = async (options, ctx) => {
    const tmpDir = context.tmpDir();
    try {
        const defContext = context.defaultContext();
        const inputs = await context.getInputs(defContext, {
            ...options,
            file: options.file || (0, node_path_1.join)((0, core_1.getProjectRoot)(ctx), 'Dockerfile'),
        }, ctx);
        const prefix = (0, devkit_1.names)(ctx?.projectName || '').constantName;
        const provider = (0, core_1.getInput)('engine', { prefix, fallback: options.engine || 'docker' });
        const engine = engine_factory_1.EngineFactory.create(provider);
        await engine.initialize(inputs, ctx);
        if (options.metadata?.images) {
            const { getMetadata } = await (0, core_1.loadPackage)('@nx-tools/container-metadata', 'Nx Container Build Executor');
            const meta = await getMetadata({ ...options.metadata, quiet: options.quiet }, ctx);
            inputs.labels = meta.getLabels();
            inputs.tags = meta.getTags();
        }
        const args = await engine.getArgs(inputs, defContext);
        const buildCmd = engine.getCommand(args);
        await core_1.logger.group('Build', async () => {
            await (0, core_1.getExecOutput)(buildCmd.command, buildCmd.args.map((arg) => (0, core_1.interpolate)(arg)), {
                ignoreReturnCode: true,
            }).then((res) => {
                if (res.stderr.length > 0 && res.exitCode != 0) {
                    throw new Error(`buildx failed with: ${res.stderr.match(/(.*)\s*$/)?.[0]?.trim() ?? 'unknown error'}`);
                }
            });
            await engine.finalize(inputs, ctx);
        });
        const imageID = await engine.getImageID();
        const metadata = await engine.getMetadata();
        const digest = await engine.getDigest(metadata);
        if (imageID) {
            await core_1.logger.group(`ImageID`, async () => {
                core_1.logger.info(imageID);
                context.setOutput('imageid', imageID, ctx);
            });
        }
        if (digest) {
            await core_1.logger.group(`Digest`, async () => {
                core_1.logger.info(digest);
                context.setOutput('digest', digest, ctx);
            });
        }
        if (metadata) {
            await core_1.logger.group(`Metadata`, async () => {
                core_1.logger.info(metadata);
                context.setOutput('metadata', metadata, ctx);
            });
        }
    }
    finally {
        await cleanup(tmpDir);
    }
    return { success: true };
};
async function cleanup(tmpDir) {
    if (tmpDir.length > 0 && (0, node_fs_1.existsSync)(tmpDir)) {
        await core_1.logger.group(`Removing temp folder ${tmpDir}`, async () => {
            await (0, promises_1.rm)(tmpDir, { recursive: true });
        });
    }
}
exports.default = runExecutor;
