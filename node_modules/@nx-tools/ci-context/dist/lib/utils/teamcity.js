"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Teamcity = void 0;
exports.repo = repo;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const promises_1 = require("fs/promises");
const properties_file_1 = require("properties-file");
const url = tslib_1.__importStar(require("url"));
const git_1 = require("./git");
// TeamCity docs: https://www.jetbrains.com/help/teamcity/predefined-build-parameters.html
class Teamcity {
    static async context() {
        const { buildProperties, configProperties } = await Teamcity.getProperties();
        return {
            name: 'TEAMCITY',
            actor: (await Teamcity.actor(configProperties)) || (await git_1.Git.getCommitUserEmail().catch(() => 'n/a')),
            eventName: configProperties['teamcity.build.triggeredBy'] || 'unknown',
            job: buildProperties['teamcity.buildConfName'],
            payload: {},
            ref: Teamcity.ref(configProperties) || '',
            runId: parseInt(buildProperties['teamcity.build.id'], 10),
            runNumber: parseInt(buildProperties['build.number'], 10),
            repoUrl: Teamcity.getRepoURL(configProperties) || '',
            sha: buildProperties['build.vcs.number'],
        };
    }
    static async getProperties() {
        const buildPropertiesFile = await (0, promises_1.readFile)(process.env['TEAMCITY_BUILD_PROPERTIES_FILE'], 'utf8');
        const buildProperties = (0, properties_file_1.getProperties)(buildPropertiesFile);
        const configPropertiesFile = await (0, promises_1.readFile)(buildProperties['teamcity.configuration.properties.file'], 'utf8');
        const configProperties = (0, properties_file_1.getProperties)(configPropertiesFile);
        return { buildProperties, configProperties };
    }
    static actor(configProperties) {
        const actor = configProperties['teamcity.build.triggeredBy.username'];
        if (actor === 'n/a')
            return;
        return actor;
    }
    static ref(configProperties) {
        let [, branch] = Object.entries(configProperties).find(([key]) => key.startsWith('teamcity.build.vcs.branch.')) ?? [];
        if (typeof branch !== 'string') {
            branch = configProperties['teamcity.build.branch'];
        }
        if (typeof branch !== 'string')
            return;
        if (branch.startsWith('refs/'))
            return branch;
        return `refs/heads/${branch}`;
    }
    static getRepoURL(configProperties) {
        let [, repo] = Object.entries(configProperties).find(([key]) => key.startsWith('vcsroot.') && key.endsWith('.url')) ?? [];
        if (typeof repo !== 'string') {
            repo = configProperties['vcsroot.url'];
        }
        if (typeof repo !== 'string') {
            return;
        }
        const ensureProto = !repo.match(/^(\w+:)?\/\//) ? '//' : '';
        // use node:url for ssh support, which URL doesn't have
        const repoURL = url.parse(ensureProto + repo.replace(/\.git$/, ''));
        repoURL.host = repoURL.hostname;
        repoURL.auth = '';
        repoURL.protocol = 'https';
        repoURL.pathname = repoURL.pathname?.replace('/:', '/') ?? null;
        if (configProperties['version'] === 'gerrit') {
            const DEFAULT_GERRIT_SSH_PORT = '29418';
            repoURL.port = repoURL.port === DEFAULT_GERRIT_SSH_PORT ? null : repoURL.port;
            repoURL.pathname = repoURL.pathname ? `/q/project:` + encodeURIComponent(repoURL.pathname.substring(1)) : '';
        }
        return url.format(repoURL);
    }
}
exports.Teamcity = Teamcity;
async function repo() {
    const { buildProperties, configProperties } = await Teamcity.getProperties();
    return {
        default_branch: configProperties['git.main.branch'] || '',
        description: '',
        html_url: Teamcity.getRepoURL(configProperties) || '',
        license: null,
        name: buildProperties['teamcity.projectName'],
    };
}
