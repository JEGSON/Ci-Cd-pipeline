"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = void 0;
exports.repo = repo;
const core_1 = require("@nx-tools/core");
class Git {
    static async context() {
        return {
            name: 'GIT',
            actor: await Git.getCommitUserEmail(),
            eventName: 'push',
            job: 'build',
            payload: {},
            ref: await Git.ref(),
            runId: 0,
            runNumber: 0,
            repoUrl: await Git.remoteURL(),
            sha: await Git.fullCommit(),
        };
    }
    static async remoteURL() {
        return await Git.exec(['remote', 'get-url', 'origin']).then((rurl) => {
            if (rurl.length == 0) {
                return Git.exec(['remote', 'get-url', 'upstream']).then((rurl) => {
                    if (rurl.length == 0) {
                        throw new Error(`Cannot find remote URL for origin or upstream`);
                    }
                    return rurl;
                });
            }
            return rurl;
        });
    }
    static async ref() {
        const isHeadDetached = await Git.isHeadDetached();
        if (isHeadDetached) {
            return await Git.getDetachedRef();
        }
        return await Git.exec(['symbolic-ref', 'HEAD']);
    }
    static async fullCommit() {
        return await Git.exec(['show', '--format=%H', 'HEAD', '--quiet', '--']);
    }
    static async tag() {
        return await Git.exec(['tag', '--points-at', 'HEAD', '--sort', '-version:creatordate']).then((tags) => {
            if (tags.length == 0) {
                return Git.exec(['describe', '--tags', '--abbrev=0']);
            }
            return tags.split('\n')[0];
        });
    }
    static async getCommitUserEmail() {
        return await Git.exec(['log', '-1', '--pretty=format:%ae']);
    }
    static async isHeadDetached() {
        return await Git.exec(['branch', '--show-current']).then((res) => {
            return res.length == 0;
        });
    }
    static async getDetachedRef() {
        const res = await Git.exec(['show', '-s', '--pretty=%D']);
        // Can be "HEAD, <tagname>" or "grafted, HEAD, <tagname>"
        const refMatch = res.match(/^(grafted, )?HEAD, (.*)$/);
        if (!refMatch || !refMatch[2]) {
            throw new Error(`Cannot find detached HEAD ref in "${res}"`);
        }
        const ref = refMatch[2].trim();
        // Tag refs are formatted as "tag: <tagname>"
        if (ref.startsWith('tag: ')) {
            return `refs/tags/${ref.split(':')[1].trim()}`;
        }
        // Branch refs are formatted as "<origin>/<branch-name>, <branch-name>"
        const branchMatch = ref.match(/^[^/]+\/[^/]+, (.+)$/);
        if (branchMatch) {
            return `refs/heads/${branchMatch[1].trim()}`;
        }
        // Pull request merge refs are formatted as "pull/<number>/<state>"
        const prMatch = ref.match(/^pull\/\d+\/(head|merge)$/);
        if (prMatch) {
            return `refs/${ref}`;
        }
        throw new Error(`Unsupported detached HEAD ref in "${res}"`);
    }
    static async exec(args = []) {
        return await (0, core_1.getExecOutput)(`git`, args, {
            ignoreReturnCode: true,
            silent: true,
        }).then((res) => {
            if (res.stderr.length > 0 && res.exitCode != 0) {
                throw new Error(res.stderr);
            }
            return res.stdout.trim();
        });
    }
}
exports.Git = Git;
async function repo() {
    return {
        default_branch: '',
        description: '',
        html_url: await Git.remoteURL(),
        license: null,
        name: '',
    };
}
