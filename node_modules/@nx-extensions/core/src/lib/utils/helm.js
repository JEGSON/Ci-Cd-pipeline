"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHelmClient = exports.HelmClient = void 0;
const tslib_1 = require("tslib");
const exec_1 = require("@actions/exec");
const types_1 = require("./types");
const utils_1 = require("./utils");
/** Helm wrapper class */
class HelmClient extends types_1.AbstractHelmClient {
    /**
     * Package a chart directory into a chart archive
     *
     * @param {PackageOptions} [options]
     */
    package(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let chartPath = undefined;
            yield (0, exec_1.getExecOutput)('helm', [
                'package',
                options.chartFolder,
                '-d',
                options.outputFolder,
            ]).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Failed to package chart: ${output.stderr}`);
                }
                const stdout = output.stdout;
                const match = stdout.match(/Successfully packaged chart and saved it to: (.+)/);
                if (!match) {
                    throw new Error('Failed to parse chart path from helm output');
                }
                chartPath = match[1].trim();
            });
            return chartPath;
        });
    }
    push(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, exec_1.getExecOutput)('helm', [
                'push',
                options.chartPath,
                options.remote,
            ]).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Failed to push chart: ${output.stderr}`);
                }
            });
        });
    }
    dependencyUpdate(chartFolder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, exec_1.getExecOutput)('helm', ['dependency', 'update', chartFolder]).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Failed to update chart dependencies: ${output.stderr}`);
                }
            });
        });
    }
    dependencyBuild(chartFolder) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, exec_1.getExecOutput)('helm', ['dependency', 'build', chartFolder]).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Failed to build chart dependencies: ${output.stderr}`);
                }
            });
        });
    }
    addRepository(name, url) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield (0, exec_1.getExecOutput)('helm', ['repo', 'add', name, url]).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Failed to add repository: ${output.stderr}`);
                }
            });
        });
    }
    /**
     * Initialize Helm
     *
     * @returns {Promise<void>}
     */
    initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.initialized) {
                return;
            }
            yield (0, exec_1.getExecOutput)('helm', ['version']).then((output) => {
                if (output.stderr.length > 0 && output.exitCode !== 0) {
                    throw new Error(`Helm is not installed: ${output.stderr}`);
                }
                this.initialized = true;
            });
        });
    }
}
exports.HelmClient = HelmClient;
tslib_1.__decorate([
    utils_1.ensureInitialized,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], HelmClient.prototype, "package", null);
tslib_1.__decorate([
    utils_1.ensureInitialized,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], HelmClient.prototype, "push", null);
tslib_1.__decorate([
    utils_1.ensureInitialized,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], HelmClient.prototype, "dependencyUpdate", null);
tslib_1.__decorate([
    utils_1.ensureInitialized,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], HelmClient.prototype, "dependencyBuild", null);
tslib_1.__decorate([
    utils_1.ensureInitialized,
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], HelmClient.prototype, "addRepository", null);
/**
 * Create a new Helm client instance
 *
 * @returns {HelmClient}
 */
const createHelmClient = () => {
    return new HelmClient();
};
exports.createHelmClient = createHelmClient;
//# sourceMappingURL=helm.js.map